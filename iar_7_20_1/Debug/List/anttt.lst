###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        30/May/2018  11:07:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\application\anttt.c
#    Command line =  
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\application\anttt.c -D NRF51
#        -lC C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\Debug\List\ -o
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\bsp\ -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\application\ -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\
#        -I
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\
#        -On --require_prototypes -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\Debug\List\anttt.lst
#    Object file  =  
#        C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\iar_7_20_1\Debug\Obj\anttt.o
#
###############################################################################

C:\Users\ENGENUICS5\Desktop\ANTTT-Jason\application\anttt.c
      1          /**********************************************************************************************************************
      2          File: anttt.c                                                                
      3          
      4          Description:
      5          Implements TIC-TAC-TOE using data input from ANT or BLE.
      6          
      7          
      8          
      9          **********************************************************************************************************************/
     10          
     11          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_clear(uint32_t)
   \                     nrf_gpio_pin_clear: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable8  ;; 0x5000050c
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_toggle(uint32_t)
   \                     nrf_gpio_pin_toggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4081             LSLS     R1,R1,R0
   \   00000006   0x....             LDR      R2,??DataTable8_1  ;; 0x50000504
   \   00000008   0x6813             LDR      R3,[R2, #+0]
   \   0000000A   0x40C3             LSRS     R3,R3,R0
   \   0000000C   0x001A             MOVS     R2,R3
   \   0000000E   0x07D2             LSLS     R2,R2,#+31       ;; ZeroExtS R2,R2,#+31,#+31
   \   00000010   0x0FD2             LSRS     R2,R2,#+31
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD102             BNE      ??nrf_gpio_pin_toggle_0
   \   00000016   0x....             LDR      R3,??DataTable8_2  ;; 0x50000508
   \   00000018   0x6019             STR      R1,[R3, #+0]
   \   0000001A   0xE001             B        ??nrf_gpio_pin_toggle_1
   \                     ??nrf_gpio_pin_toggle_0: (+1)
   \   0000001C   0x....             LDR      R3,??DataTable8  ;; 0x5000050c
   \   0000001E   0x6019             STR      R1,[R3, #+0]
   \                     ??nrf_gpio_pin_toggle_1: (+1)
   \   00000020   0xBD00             POP      {PC}             ;; return
     12          
     13          /***********************************************************************************************************************
     14          Global variable definitions with scope across entire project.
     15          All Global variable names shall start with "G_xxAnttt"
     16          ***********************************************************************************************************************/
     17          /* New variables */

   \                                 In section .bss, align 4
     18          u32 G_u32AntttFlags;                                     /* Global state flags */
   \                     G_u32AntttFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     19          fnCode_type ANTTT_SM;
   \                     ANTTT_SM:
   \   00000000                      DS8 4
     20          
     21          /*--------------------------------------------------------------------------------------------------------------------*/
     22          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     23          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     24          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     25          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     26          extern volatile u32 G_u32BPEngenuicsFlags;             /* From bleperipheral_engenuics.c  */
     27          
     28          
     29          /***********************************************************************************************************************
     30          Global variable definitions with scope limited to this local application.
     31          Variable names shall start with "Anttt_<type>" and be declared as static.
     32          ***********************************************************************************************************************/
     33          //static u32 Anttt_u32Timeout;                             /* Timeout counter used across states */
     34          //static u32 Anttt_u32CyclePeriod;                         /* Current base time for Anttt modulation */

   \                                 In section .bss, align 4
     35          static u8 Anttt_u8RxData[ANTTT_COMMAND_SIZE];
   \                     Anttt_u8RxData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     36          static u16 Anttt_u16HomeState;
   \                     Anttt_u16HomeState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     37          static u16 Anttt_u16AwayState;
   \                     Anttt_u16AwayState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     38          static bool Anttt_bPendingResponse;
   \                     Anttt_bPendingResponse:
   \   00000000                      DS8 1
     39          

   \                                 In section .data, align 4
     40          u16 au16WinningCombos[] = 
   \                     au16WinningCombos:
   \   00000000   0x0007 0x0038      DC16 7, 56, 448, 73, 146, 292, 273, 84
   \              0x01C0 0x0049
   \              0x0092 0x0124
   \              0x0111 0x0054
     41          {
     42            0x0007,        // 0b000000111
     43            0x0038,        // 0b000111000
     44            0x01C0,        // 0b111000000
     45            0x0049,        // 0b001001001
     46            0x0092,        // 0b010010010
     47            0x0124,        // 0b100100100
     48            0x0111,        // 0b100010001
     49            0x0054         // 0b001010100
     50          };
     51          
     52          
     53          
     54          /**********************************************************************************************************************
     55          Function Definitions
     56          **********************************************************************************************************************/
     57          
     58          /*--------------------------------------------------------------------------------------------------------------------*/
     59          /* Public functions                                                                                                   */
     60          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     61          void AntttIncomingMessage(u8* pu8Data_, u8 u8Length_)
     62          {
   \                     AntttIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     63            // Check length of the Command Size.
     64            if (u8Length_ != ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttIncomingMessage_0
     65            {
     66              return;
     67            }
     68            
     69            memcpy(Anttt_u8RxData, pu8Data_, u8Length_);
   \                     ??AntttIncomingMessage_1: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable8_3
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
     70          }
   \                     ??AntttIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
     71          
     72          
     73          /*--------------------------------------------------------------------------------------------------------------------*/
     74          /* Protected functions                                                                                                */
     75          /*--------------------------------------------------------------------------------------------------------------------*/
     76          
     77          /*--------------------------------------------------------------------------------------------------------------------
     78          Function: AntttInitialize
     79          
     80          Description:
     81          Initializes the State Machine and its variables.
     82          
     83          Requires:
     84          
     85          Promises:
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          void AntttInitialize(void)
     88          {
   \                     AntttInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     89            Anttt_reset_rx_buffer();
   \   00000002   0x.... 0x....      BL       Anttt_reset_rx_buffer
     90            Anttt_u16HomeState = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable8_4
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
     91            Anttt_u16AwayState = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR      R1,??DataTable8_5
   \   00000010   0x8008             STRH     R0,[R1, #+0]
     92            ANTTT_SM = &AntttSM_Idle;
   \   00000012   0x....             LDR      R0,??DataTable8_6
   \   00000014   0x....             LDR      R1,??DataTable8_7
   \   00000016   0x6008             STR      R0,[R1, #+0]
     93            Anttt_bPendingResponse = false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR      R1,??DataTable8_8
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
     94            
     95            // Set up initial LEDs.
     96            LedOn(STATUS_RED);
   \   0000001E   0x2012             MOVS     R0,#+18
   \   00000020   0x.... 0x....      BL       LedOn
     97            LedOff(STATUS_YLW);
   \   00000024   0x2013             MOVS     R0,#+19
   \   00000026   0x.... 0x....      BL       LedOff
     98            LedOff(STATUS_GRN);
   \   0000002A   0x2014             MOVS     R0,#+20
   \   0000002C   0x.... 0x....      BL       LedOff
     99            
    100            for (u8 u8Led = 0; u8Led < (TOTAL_BUTTONS * 2); u8Led++)
   \   00000030   0x2400             MOVS     R4,#+0
   \                     ??AntttInitialize_0: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4
   \   00000034   0x2C12             CMP      R4,#+18
   \   00000036   0xDA05             BGE      ??AntttInitialize_1
    101            {
    102              LedOff((LedNumberType) u8Led);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       LedOff
    103            }
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \   00000042   0xE7F6             B        ??AntttInitialize_0
    104            
    105            nrf_gpio_pin_clear(16);
   \                     ??AntttInitialize_1: (+1)
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0x.... 0x....      BL       nrf_gpio_pin_clear
    106            
    107          } /* end AntttInitialize() */
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    108          
    109          
    110          /*--------------------------------------------------------------------------------------------------------------------
    111          Function: AntttHandleIncomingMessage(u8* pu8Data_, u8 u8Length_)
    112          
    113          Description:
    114          Copies incoming data to the Anttt Rx buffer.
    115          
    116          Requires:
    117          - pu8Data_ points to the data string
    118          - u8Length_ is the size of the data
    119          
    120          Promises:
    121          - Anttt_u8RxData is filled with pu8Data_ if length is correct;
    122            otherwise does nothing.
    123          */

   \                                 In section .text, align 2, keep-with-next
    124          void AntttHandleIncomingMessage(u8* pu8Data_, u8 u8Length_)
    125          {
   \                     AntttHandleIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    126            // Check the appropriate length.
    127            if (u8Length_ == ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttHandleIncomingMessage_0
    128            {
    129              memcpy(Anttt_u8RxData, pu8Data_, u8Length_);
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable9
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    130            }
    131          }
   \                     ??AntttHandleIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    132          
    133          
    134          /*--------------------------------------------------------------------------------------------------------------------*/
    135          /* Private functions                                                                                                  */
    136          /*--------------------------------------------------------------------------------------------------------------------*/
    137          
    138          /*--------------------------------------------------------------------------------------------------------------------
    139          Function: static bool AntttIsGameOver(void)
    140          
    141          Description:
    142          Check to see how a game has ended
    143          
    144          Requires:
    145          - Anttt_u16HomeState holds the game data for the "home" team
    146          - Anttt_u16AwayState holds the game data for the "away" team
    147          
    148          Promises:
    149          - Anttt_u8RxData is filled with pu8Data_ if length is correct;
    150            otherwise does nothing.
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          static bool AntttIsGameOver(void)
    153          {
   \                     AntttIsGameOver: (+1)
   \   00000000   0xB500             PUSH     {LR}
    154            // Check all 8 winning combinations.
    155            for (u8 i = 0; i < 8; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \                     ??AntttIsGameOver_0: (+1)
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2808             CMP      R0,#+8
   \   00000008   0xDA3F             BGE      ??AntttIsGameOver_1
    156            {
    157              if ((Anttt_u16HomeState & au16WinningCombos[i]) == au16WinningCombos[i])
   \   0000000A   0x....             LDR      R1,??DataTable8_4
   \   0000000C   0x8809             LDRH     R1,[R1, #+0]
   \   0000000E   0x....             LDR      R2,??DataTable8_9
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x4343             MULS     R3,R0,R3
   \   00000016   0x5AD2             LDRH     R2,[R2, R3]
   \   00000018   0x400A             ANDS     R2,R2,R1
   \   0000001A   0x....             LDR      R1,??DataTable8_9
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2302             MOVS     R3,#+2
   \   00000020   0x4343             MULS     R3,R0,R3
   \   00000022   0x5AC9             LDRH     R1,[R1, R3]
   \   00000024   0x428A             CMP      R2,R1
   \   00000026   0xD10F             BNE      ??AntttIsGameOver_2
    158              {
    159                Anttt_u16HomeState  = au16WinningCombos[i];
   \   00000028   0x....             LDR      R1,??DataTable8_9
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x4350             MULS     R0,R2,R0
   \   00000030   0x5A08             LDRH     R0,[R1, R0]
   \   00000032   0x....             LDR      R1,??DataTable8_4
   \   00000034   0x8008             STRH     R0,[R1, #+0]
    160                Anttt_u16HomeState |= _U16_ANTTT_WIN_FLAG;       // Set this flag to indicate home won.
   \   00000036   0x....             LDR      R0,??DataTable8_4
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000003E   0x4301             ORRS     R1,R1,R0
   \   00000040   0x....             LDR      R0,??DataTable8_4
   \   00000042   0x8001             STRH     R1,[R0, #+0]
    161                
    162                return true;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE02B             B        ??AntttIsGameOver_3
    163              }
    164              else if ( (Anttt_u16AwayState & au16WinningCombos[i]) == au16WinningCombos[i])
   \                     ??AntttIsGameOver_2: (+1)
   \   00000048   0x....             LDR      R1,??DataTable8_5
   \   0000004A   0x8809             LDRH     R1,[R1, #+0]
   \   0000004C   0x....             LDR      R2,??DataTable8_9
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x2302             MOVS     R3,#+2
   \   00000052   0x4343             MULS     R3,R0,R3
   \   00000054   0x5AD2             LDRH     R2,[R2, R3]
   \   00000056   0x400A             ANDS     R2,R2,R1
   \   00000058   0x....             LDR      R1,??DataTable8_9
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x2302             MOVS     R3,#+2
   \   0000005E   0x4343             MULS     R3,R0,R3
   \   00000060   0x5AC9             LDRH     R1,[R1, R3]
   \   00000062   0x428A             CMP      R2,R1
   \   00000064   0xD10F             BNE      ??AntttIsGameOver_4
    165              {
    166                Anttt_u16AwayState = au16WinningCombos[i];
   \   00000066   0x....             LDR      R1,??DataTable8_9
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0x2202             MOVS     R2,#+2
   \   0000006C   0x4350             MULS     R0,R2,R0
   \   0000006E   0x5A08             LDRH     R0,[R1, R0]
   \   00000070   0x....             LDR      R1,??DataTable8_5
   \   00000072   0x8008             STRH     R0,[R1, #+0]
    167                Anttt_u16AwayState |= _U16_ANTTT_WIN_FLAG;       // Set this flag to indicate away winning won.
   \   00000074   0x....             LDR      R0,??DataTable8_5
   \   00000076   0x8800             LDRH     R0,[R0, #+0]
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000007C   0x4301             ORRS     R1,R1,R0
   \   0000007E   0x....             LDR      R0,??DataTable8_5
   \   00000080   0x8001             STRH     R1,[R0, #+0]
    168                
    169                return true;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE00C             B        ??AntttIsGameOver_3
    170              }
    171            }
   \                     ??AntttIsGameOver_4: (+1)
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0xE7BC             B        ??AntttIsGameOver_0
    172            
    173            // Check if draw.
    174            if ((Anttt_u16HomeState | Anttt_u16AwayState) == U16_ANTTT_DRAW)
   \                     ??AntttIsGameOver_1: (+1)
   \   0000008A   0x....             LDR      R0,??DataTable8_4
   \   0000008C   0x8800             LDRH     R0,[R0, #+0]
   \   0000008E   0x....             LDR      R1,??DataTable8_5
   \   00000090   0x8809             LDRH     R1,[R1, #+0]
   \   00000092   0x4301             ORRS     R1,R1,R0
   \   00000094   0x....             LDR      R0,??DataTable9_1  ;; 0x1ff
   \   00000096   0x4281             CMP      R1,R0
   \   00000098   0xD101             BNE      ??AntttIsGameOver_5
    175            {
    176              return true;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE000             B        ??AntttIsGameOver_3
    177            }
    178            
    179            return false;
   \                     ??AntttIsGameOver_5: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??AntttIsGameOver_3: (+1)
   \   000000A0   0xBD00             POP      {PC}             ;; return
    180          }
    181          
    182          
    183          /*--------------------------------------------------------------------------------------------------------------------
    184          Function: static void Anttt_reset_rx_buffer(void)
    185          
    186          Description:
    187          Clear the Rx buffer
    188          
    189          Requires:
    190          - 
    191          
    192          Promises:
    193          - Anttt_u8RxData is filled with 0xFF
    194          */

   \                                 In section .text, align 2, keep-with-next
    195          static void Anttt_reset_rx_buffer(void)
    196          {
   \                     Anttt_reset_rx_buffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    197            u8 u8Status;
    198            
    199            SystemEnterCriticalSection(&u8Status);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       SystemEnterCriticalSection
    200            memset(Anttt_u8RxData, 0xFF, ANTTT_COMMAND_SIZE);   
   \   0000000A   0x2503             MOVS     R5,#+3
   \   0000000C   0x24FF             MOVS     R4,#+255
   \   0000000E   0x....             LDR      R6,??DataTable9
   \   00000010   0x0022             MOVS     R2,R4
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memset
    201            SystemExitCriticalSection(u8Status);
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       SystemExitCriticalSection
    202          }
   \   00000022   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    203          
    204          
    205          /*--------------------------------------------------------------------------------------------------------------------*/
    206          /* State Machine definitions                                                                                          */
    207          /*--------------------------------------------------------------------------------------------------------------------*/
    208          
    209          /*--------------------------------------------------------------------------------------------------------------------
    210          State: AntttSM_Idle
    211          */

   \                                 In section .text, align 2, keep-with-next
    212          static void AntttSM_Idle(void)
    213          {
   \                     AntttSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    214            // Check if module is connected to client.
    215            if (G_u32BPEngenuicsFlags == _BPENGENUICS_CONNECTED)
   \   00000002   0x....             LDR      R0,??DataTable9_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD107             BNE      ??AntttSM_Idle_0
    216            {
    217              // Set LEDs and proceed to wait state.
    218              LedOn(STATUS_GRN);   // Connected to Client.
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0x.... 0x....      BL       LedOn
    219              
    220              // Reset any pending button states incase the user was pressing while waiting.
    221              ButtonInitialize();
   \   00000010   0x.... 0x....      BL       ButtonInitialize
    222              
    223              ANTTT_SM = &AntttSM_Wait;
   \   00000014   0x....             LDR      R0,??DataTable9_3
   \   00000016   0x....             LDR      R1,??DataTable8_7
   \   00000018   0x6008             STR      R0,[R1, #+0]
    224            }
    225            
    226          #if 0
    227            /* TEST CODE TO TEST BUTTONS */
    228            for (u8 i = 0; i < TOTAL_BUTTONS; i++)
    229            {
    230             if (WasButtonPressed(i))
    231             {
    232               LedToggle(0xFF);
    233               ButtonAcknowledge(i);
    234               return;
    235             }
    236            }
    237          #endif
    238            
    239          } 
   \                     ??AntttSM_Idle_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    240          
    241          /*--------------------------------------------------------------------------------------------------------------------
    242          State: AntttSM_Wait
    243          Wait for the other player to make a move.
    244          */

   \                                 In section .text, align 2, keep-with-next
    245          static void AntttSM_Wait(void)
    246          {
   \                     AntttSM_Wait: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    247            u8 au8Temp[ANTTT_COMMAND_SIZE] = {0, 0, 0};
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #0]
    248            u8 u8Position;
    249            
    250            // Check if module has established connection with client.
    251            if (G_u32BPEngenuicsFlags & _BPENGENUICS_CONNECTED)
   \   00000008   0x....             LDR      R0,??DataTable9_2
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD554             BPL      ??AntttSM_Wait_0
    252            {
    253              // Wait for Client to make a move.
    254              if (Anttt_u8RxData[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE)
   \   00000010   0x....             LDR      R0,??DataTable8_3
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x28CC             CMP      R0,#+204
   \   00000016   0xD152             BNE      ??AntttSM_Wait_1
    255              {
    256                u8Position = Anttt_u8RxData[ANTTT_COMMAND_POSITION_OFFSET];
   \   00000018   0x....             LDR      R0,??DataTable8_3
   \   0000001A   0x7840             LDRB     R0,[R0, #+1]
   \   0000001C   0x0004             MOVS     R4,R0
    257                      
    258                // Check if position is already chosen or incorrect position sent.
    259                if ( (Anttt_u16HomeState & (1 << u8Position)) || 
    260                     (Anttt_u16AwayState & (1 << u8Position)) ||
    261                     (u8Position >= TOTAL_BUTTONS) )
   \   0000001E   0x....             LDR      R0,??DataTable8_4
   \   00000020   0x8800             LDRH     R0,[R0, #+0]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x40A1             LSLS     R1,R1,R4
   \   00000026   0x4208             TST      R0,R1
   \   00000028   0xD108             BNE      ??AntttSM_Wait_2
   \   0000002A   0x....             LDR      R0,??DataTable8_5
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x40A1             LSLS     R1,R1,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD102             BNE      ??AntttSM_Wait_2
   \   00000036   0xB2E4             UXTB     R4,R4
   \   00000038   0x2C09             CMP      R4,#+9
   \   0000003A   0xDB07             BLT      ??AntttSM_Wait_3
    262                {
    263                  // Send NACK response.
    264                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_NACK;
   \                     ??AntttSM_Wait_2: (+1)
   \   0000003C   0x20BC             MOVS     R0,#+188
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    265                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       BPEngenuicsSendData
   \   0000004A   0xE033             B        ??AntttSM_Wait_4
    266                }
    267                else
    268                {
    269                  // New Position.
    270                  LedOn((LedNumberType) (u8Position + U8_AWAY_POSITION_OFFSET));  
   \                     ??AntttSM_Wait_3: (+1)
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x3009             ADDS     R0,R0,#+9
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x.... 0x....      BL       LedOn
    271                  Anttt_u16AwayState |= 1 << (u8Position);
   \   00000056   0x....             LDR      R0,??DataTable8_5
   \   00000058   0x8800             LDRH     R0,[R0, #+0]
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x40A1             LSLS     R1,R1,R4
   \   0000005E   0x4301             ORRS     R1,R1,R0
   \   00000060   0x....             LDR      R0,??DataTable8_5
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    272                  
    273                  // Send response.
    274                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_ACK;
   \   00000064   0x20AC             MOVS     R0,#+172
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    275                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       BPEngenuicsSendData
    276                  
    277                  // Check if game is over.
    278                  if (AntttIsGameOver())
   \   00000072   0x.... 0x....      BL       AntttIsGameOver
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD016             BEQ      ??AntttSM_Wait_5
    279                  {
    280                    // Set up initial LEDs.
    281                    LedOff(STATUS_RED);
   \   0000007A   0x2012             MOVS     R0,#+18
   \   0000007C   0x.... 0x....      BL       LedOff
    282                    LedOff(STATUS_YLW);
   \   00000080   0x2013             MOVS     R0,#+19
   \   00000082   0x.... 0x....      BL       LedOff
    283                    LedOff(STATUS_GRN);
   \   00000086   0x2014             MOVS     R0,#+20
   \   00000088   0x.... 0x....      BL       LedOff
    284              
    285                    for (u8 i = 0; i < (TOTAL_BUTTONS * 2); i++)
   \   0000008C   0x2500             MOVS     R5,#+0
   \                     ??AntttSM_Wait_6: (+1)
   \   0000008E   0xB2ED             UXTB     R5,R5
   \   00000090   0x2D12             CMP      R5,#+18
   \   00000092   0xDA05             BGE      ??AntttSM_Wait_7
    286                    {
    287                      LedOff((LedNumberType) i);
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x.... 0x....      BL       LedOff
    288                    }
   \   0000009C   0x1C6D             ADDS     R5,R5,#+1
   \   0000009E   0xE7F6             B        ??AntttSM_Wait_6
    289                    
    290                    ANTTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Wait_7: (+1)
   \   000000A0   0x....             LDR      R0,??DataTable10
   \   000000A2   0x....             LDR      R1,??DataTable8_7
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    291                    return;
   \   000000A6   0xE01C             B        ??AntttSM_Wait_8
    292                  }
    293          
    294                  // Update State.
    295                  ANTTT_SM = &AntttSM_Active;
   \                     ??AntttSM_Wait_5: (+1)
   \   000000A8   0x....             LDR      R0,??DataTable10_1
   \   000000AA   0x....             LDR      R1,??DataTable8_7
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    296                  LedOn(STATUS_YLW);
   \   000000AE   0x2013             MOVS     R0,#+19
   \   000000B0   0x.... 0x....      BL       LedOn
    297                }
    298                
    299                /* Regardless, clear the Rx buffer */
    300                Anttt_reset_rx_buffer();
   \                     ??AntttSM_Wait_4: (+1)
   \   000000B4   0x.... 0x....      BL       Anttt_reset_rx_buffer
   \   000000B8   0xE001             B        ??AntttSM_Wait_1
    301                
    302              }
    303            } /* end if (G_u32BPEngenuicsFlags & _BPENGENUICS_CONNECTED) */
    304            else
    305            {
    306              // Disconnected from client.
    307              AntttInitialize();
   \                     ??AntttSM_Wait_0: (+1)
   \   000000BA   0x.... 0x....      BL       AntttInitialize
    308            }
    309            
    310            // User may be pressing buttons in this state, Ack the button presses to 
    311            // disable queuing of the presses as valid game presses.
    312            for (u32 u32Button = 0; u32Button < TOTAL_BUTTONS; u32Button++)
   \                     ??AntttSM_Wait_1: (+1)
   \   000000BE   0x2500             MOVS     R5,#+0
   \                     ??AntttSM_Wait_9: (+1)
   \   000000C0   0x2D09             CMP      R5,#+9
   \   000000C2   0xD20E             BCS      ??AntttSM_Wait_10
    313            {
    314              if (WasButtonPressed(u32Button) & !Anttt_bPendingResponse)
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0x.... 0x....      BL       WasButtonPressed
   \   000000CA   0x....             LDR      R1,??DataTable10_2
   \   000000CC   0x7809             LDRB     R1,[R1, #+0]
   \   000000CE   0x2201             MOVS     R2,#+1
   \   000000D0   0x404A             EORS     R2,R2,R1
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x4210             TST      R0,R2
   \   000000D6   0xD002             BEQ      ??AntttSM_Wait_11
    315              {
    316                ButtonAcknowledge(u32Button);  
   \   000000D8   0x0028             MOVS     R0,R5
   \   000000DA   0x.... 0x....      BL       ButtonAcknowledge
    317              }
    318            }
   \                     ??AntttSM_Wait_11: (+1)
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
   \   000000E0   0xE7EE             B        ??AntttSM_Wait_9
    319          }
   \                     ??AntttSM_Wait_10: (+1)
   \                     ??AntttSM_Wait_8: (+1)
   \   000000E2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    320          
    321          /*--------------------------------------------------------------------------------------------------------------------
    322          State: AntttSM_Active
    323          Local player makes a move
    324          */

   \                                 In section .text, align 2, keep-with-next
    325          static void AntttSM_Active(void)
    326          {
   \                     AntttSM_Active: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    327            // Check if module has established connection with client.
    328            if (G_u32BPEngenuicsFlags & _BPENGENUICS_SERVICE_ENABLED)
   \   00000004   0x....             LDR      R0,??DataTable9_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD572             BPL      ??AntttSM_Active_0
    329            {
    330              // Make a move.
    331              // Check if a button was pressed, then update UI and send message.  
    332              for (u8 u8Button = 0; u8Button < TOTAL_BUTTONS; u8Button++)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_1: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4
   \   00000010   0x2C09             CMP      R4,#+9
   \   00000012   0xDA43             BGE      ??AntttSM_Active_2
    333              {
    334                if (WasButtonPressed(u8Button) & !Anttt_bPendingResponse)
   \   00000014   0xB2E4             UXTB     R4,R4
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       WasButtonPressed
   \   0000001C   0x....             LDR      R1,??DataTable10_2
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x404A             EORS     R2,R2,R1
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x4210             TST      R0,R2
   \   00000028   0xD02E             BEQ      ??AntttSM_Active_3
    335                {
    336                  u8 au8Temp[ANTTT_COMMAND_SIZE];
    337                  
    338                  // Check if a valid press. Check if position already chosen via client
    339                  // or itself or incorrect button index reported
    340                  if ( (Anttt_u16HomeState & (1 << u8Button)) || 
    341                       (Anttt_u16AwayState & (1 << u8Button)) ||
    342                       (u8Button >= TOTAL_BUTTONS))
   \   0000002A   0x....             LDR      R0,??DataTable10_3
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x40A1             LSLS     R1,R1,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD108             BNE      ??AntttSM_Active_4
   \   00000036   0x....             LDR      R0,??DataTable10_4
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x40A1             LSLS     R1,R1,R4
   \   0000003E   0x4208             TST      R0,R1
   \   00000040   0xD102             BNE      ??AntttSM_Active_4
   \   00000042   0xB2E4             UXTB     R4,R4
   \   00000044   0x2C09             CMP      R4,#+9
   \   00000046   0xDB00             BLT      ??AntttSM_Active_5
    343                  {
    344                    continue;
   \                     ??AntttSM_Active_4: (+1)
   \   00000048   0xE026             B        ??AntttSM_Active_6
    345                  }
    346                  
    347                  // Button index directly corresponds to Home LED Index.
    348                  // First Update UI.
    349                  LedOn((LedNumberType) u8Button);
   \                     ??AntttSM_Active_5: (+1)
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       LedOn
    350                  Anttt_u16HomeState |= 1 << (u8Button);
   \   00000052   0x....             LDR      R0,??DataTable10_3
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x40A1             LSLS     R1,R1,R4
   \   0000005A   0x4301             ORRS     R1,R1,R0
   \   0000005C   0x....             LDR      R0,??DataTable10_3
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
    351                  
    352                  // Send message to client.
    353                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE;
   \   00000060   0x20CC             MOVS     R0,#+204
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    354                  au8Temp[ANTTT_COMMAND_POSITION_OFFSET] = u8Button;
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7044             STRB     R4,[R0, #+1]
    355                  au8Temp[ANTTT_COMMAND_SOURCE_OFFSET] = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x7088             STRB     R0,[R1, #+2]
    356                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x.... 0x....      BL       BPEngenuicsSendData
    357                  
    358                  ButtonAcknowledge(u8Button);   
   \   00000078   0xB2E4             UXTB     R4,R4
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       ButtonAcknowledge
    359                  Anttt_bPendingResponse = true;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x....             LDR      R1,??DataTable10_2
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    360                  return;
   \   00000086   0xE036             B        ??AntttSM_Active_7
    361                }
    362                else if (Anttt_bPendingResponse)
   \                     ??AntttSM_Active_3: (+1)
   \   00000088   0x....             LDR      R0,??DataTable10_2
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD003             BEQ      ??AntttSM_Active_6
    363                {
    364                  // User may be pressing buttons in this state, Ack the button presses to 
    365                  // disable queuing of the presses as valid game presses.
    366                  ButtonAcknowledge(u8Button);    
   \   00000090   0xB2E4             UXTB     R4,R4
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       ButtonAcknowledge
    367                }
    368              }
   \                     ??AntttSM_Active_6: (+1)
   \   00000098   0x1C64             ADDS     R4,R4,#+1
   \   0000009A   0xE7B8             B        ??AntttSM_Active_1
    369              
    370              // Check if response received.
    371              if (Anttt_u8RxData[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE_ACK)
   \                     ??AntttSM_Active_2: (+1)
   \   0000009C   0x....             LDR      R0,??DataTable9
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x28AC             CMP      R0,#+172
   \   000000A2   0xD128             BNE      ??AntttSM_Active_8
    372              {
    373                Anttt_reset_rx_buffer();
   \   000000A4   0x.... 0x....      BL       Anttt_reset_rx_buffer
    374                Anttt_bPendingResponse = false;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x....             LDR      R1,??DataTable10_2
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    375                
    376                // Check if game is over.
    377                if (AntttIsGameOver())
   \   000000AE   0x.... 0x....      BL       AntttIsGameOver
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD016             BEQ      ??AntttSM_Active_9
    378                {
    379                  // Set up initial LEDs.
    380                  LedOff(STATUS_RED);
   \   000000B6   0x2012             MOVS     R0,#+18
   \   000000B8   0x.... 0x....      BL       LedOff
    381                  LedOff(STATUS_YLW);
   \   000000BC   0x2013             MOVS     R0,#+19
   \   000000BE   0x.... 0x....      BL       LedOff
    382                  LedOff(STATUS_GRN);
   \   000000C2   0x2014             MOVS     R0,#+20
   \   000000C4   0x.... 0x....      BL       LedOff
    383            
    384                  for (u8 i = 0; i < (TOTAL_BUTTONS * 2); i++)
   \   000000C8   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_10: (+1)
   \   000000CA   0xB2E4             UXTB     R4,R4
   \   000000CC   0x2C12             CMP      R4,#+18
   \   000000CE   0xDA05             BGE      ??AntttSM_Active_11
    385                  {
    386                    LedOff((LedNumberType) i);
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x.... 0x....      BL       LedOff
    387                  }
   \   000000D8   0x1C64             ADDS     R4,R4,#+1
   \   000000DA   0xE7F6             B        ??AntttSM_Active_10
    388                  
    389                  ANTTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Active_11: (+1)
   \   000000DC   0x....             LDR      R0,??DataTable10
   \   000000DE   0x....             LDR      R1,??DataTable10_5
   \   000000E0   0x6008             STR      R0,[R1, #+0]
    390                  return;
   \   000000E2   0xE008             B        ??AntttSM_Active_7
    391                }
    392                
    393                // Update State.
    394                ANTTT_SM = &AntttSM_Wait;
   \                     ??AntttSM_Active_9: (+1)
   \   000000E4   0x....             LDR      R0,??DataTable9_3
   \   000000E6   0x....             LDR      R1,??DataTable10_5
   \   000000E8   0x6008             STR      R0,[R1, #+0]
    395                LedOff(STATUS_YLW);
   \   000000EA   0x2013             MOVS     R0,#+19
   \   000000EC   0x.... 0x....      BL       LedOff
   \   000000F0   0xE001             B        ??AntttSM_Active_8
    396              }
    397            }
    398            else
    399            {
    400              // Disconnected from client.
    401              AntttInitialize();
   \                     ??AntttSM_Active_0: (+1)
   \   000000F2   0x.... 0x....      BL       AntttInitialize
    402            }
    403          }
   \                     ??AntttSM_Active_8: (+1)
   \                     ??AntttSM_Active_7: (+1)
   \   000000F6   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    404          
    405          
    406          /*--------------------------------------------------------------------------------------------------------------------
    407          State: AntttSM_Gameover
    408          Game ending sequence
    409          */

   \                                 In section .text, align 2, keep-with-next
    410          static void AntttSM_Gameover(void)
    411          {   
   \                     AntttSM_Gameover: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    412            // Play Winning Sequence. 
    413            if ((G_u32SystemTime1ms % 500) == 0)
   \   00000002   0x....             LDR      R0,??DataTable10_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x21FA             MOVS     R1,#+250
   \   00000008   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \   0000000A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD000             BEQ      .+4
   \   00000012   0xE085             B        ??AntttSM_Gameover_0
    414            {
    415              nrf_gpio_pin_toggle(16);
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       nrf_gpio_pin_toggle
    416              
    417              // Toggle LED sequences.
    418              LedToggle(STATUS_GRN);
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x.... 0x....      BL       LedToggle
    419              LedToggle(STATUS_RED);
   \   00000020   0x2012             MOVS     R0,#+18
   \   00000022   0x.... 0x....      BL       LedToggle
    420              LedToggle(STATUS_YLW);
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       LedToggle
    421              
    422              // Blink winning sequence.
    423              if (Anttt_u16HomeState & _U16_ANTTT_WIN_FLAG)
   \   0000002C   0x....             LDR      R0,??DataTable10_3
   \   0000002E   0x8800             LDRH     R0,[R0, #+0]
   \   00000030   0x0580             LSLS     R0,R0,#+22
   \   00000032   0xD51D             BPL      ??AntttSM_Gameover_1
    424              {
    425                // Home won.
    426                u8 au8Three[3];
    427                u8 u8Index = 0;
   \   00000034   0x2400             MOVS     R4,#+0
    428                u16 u16Temp = Anttt_u16HomeState;  
   \   00000036   0x....             LDR      R0,??DataTable10_3
   \   00000038   0x8805             LDRH     R5,[R0, #+0]
    429                
    430                // Convert LED bitmask to LED value.
    431                for (u8 i = 0; i < 9; i++)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_2: (+1)
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x2809             CMP      R0,#+9
   \   00000040   0xDA09             BGE      ??AntttSM_Gameover_3
    432                {
    433                  if (u16Temp & 0x01)
   \   00000042   0x07E9             LSLS     R1,R5,#+31
   \   00000044   0xD503             BPL      ??AntttSM_Gameover_4
    434                  {
    435                    au8Three[u8Index++] = i;
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0xB2E4             UXTB     R4,R4
   \   0000004A   0x5508             STRB     R0,[R1, R4]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
    436                  }
    437                  
    438                  u16Temp = u16Temp >> 1;
   \                     ??AntttSM_Gameover_4: (+1)
   \   0000004E   0xB2AD             UXTH     R5,R5
   \   00000050   0x086D             LSRS     R5,R5,#+1
    439                }
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xE7F2             B        ??AntttSM_Gameover_2
    440                
    441                LedToggle((LedNumberType)au8Three[0]);
   \                     ??AntttSM_Gameover_3: (+1)
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       LedToggle
    442                LedToggle((LedNumberType)au8Three[1]);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x7840             LDRB     R0,[R0, #+1]
   \   00000062   0x.... 0x....      BL       LedToggle
    443                LedToggle((LedNumberType)au8Three[2]);
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7880             LDRB     R0,[R0, #+2]
   \   0000006A   0x.... 0x....      BL       LedToggle
   \   0000006E   0xE057             B        ??AntttSM_Gameover_0
    444              }
    445              else if (Anttt_u16AwayState & _U16_ANTTT_WIN_FLAG)
   \                     ??AntttSM_Gameover_1: (+1)
   \   00000070   0x....             LDR      R0,??DataTable10_4
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x0580             LSLS     R0,R0,#+22
   \   00000076   0xD523             BPL      ??AntttSM_Gameover_5
    446              {
    447                // Away won.
    448                u8 au8Three[3];
    449                u8 u8Index = 0;
   \   00000078   0x2400             MOVS     R4,#+0
    450                u16 u16Temp = Anttt_u16AwayState;  
   \   0000007A   0x....             LDR      R0,??DataTable10_4
   \   0000007C   0x8805             LDRH     R5,[R0, #+0]
    451                
    452                // Convert LED bitmask to LED value.
    453                for (u8 i = 0; i < 9; i++)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_6: (+1)
   \   00000080   0xB2C0             UXTB     R0,R0
   \   00000082   0x2809             CMP      R0,#+9
   \   00000084   0xDA09             BGE      ??AntttSM_Gameover_7
    454                {
    455                  if (u16Temp & 0x01)
   \   00000086   0x07E9             LSLS     R1,R5,#+31
   \   00000088   0xD503             BPL      ??AntttSM_Gameover_8
    456                  {
    457                    au8Three[u8Index++] = i;
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0x5508             STRB     R0,[R1, R4]
   \   00000090   0x1C64             ADDS     R4,R4,#+1
    458                  }
    459                  
    460                  u16Temp = u16Temp >> 1;
   \                     ??AntttSM_Gameover_8: (+1)
   \   00000092   0xB2AD             UXTH     R5,R5
   \   00000094   0x086D             LSRS     R5,R5,#+1
    461                }
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0xE7F2             B        ??AntttSM_Gameover_6
    462                
    463                LedToggle((LedNumberType)(au8Three[0] + 9));
   \                     ??AntttSM_Gameover_7: (+1)
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x3009             ADDS     R0,R0,#+9
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x.... 0x....      BL       LedToggle
    464                LedToggle((LedNumberType)(au8Three[1] + 9));
   \   000000A6   0x4668             MOV      R0,SP
   \   000000A8   0x7840             LDRB     R0,[R0, #+1]
   \   000000AA   0x3009             ADDS     R0,R0,#+9
   \   000000AC   0xB2C0             UXTB     R0,R0
   \   000000AE   0x.... 0x....      BL       LedToggle
    465                LedToggle((LedNumberType)(au8Three[2] + 9));
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x7880             LDRB     R0,[R0, #+2]
   \   000000B6   0x3009             ADDS     R0,R0,#+9
   \   000000B8   0xB2C0             UXTB     R0,R0
   \   000000BA   0x.... 0x....      BL       LedToggle
   \   000000BE   0xE02F             B        ??AntttSM_Gameover_0
    466              }
    467              else
    468              {
    469                // Play Draw Sequence.
    470                LedToggle((LedNumberType)(0));
   \                     ??AntttSM_Gameover_5: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       LedToggle
    471                LedToggle((LedNumberType)(1));
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       LedToggle
    472                LedToggle((LedNumberType)(2));
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0x.... 0x....      BL       LedToggle
    473                LedToggle((LedNumberType)(3));
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x.... 0x....      BL       LedToggle
    474                LedToggle((LedNumberType)(5));
   \   000000D8   0x2005             MOVS     R0,#+5
   \   000000DA   0x.... 0x....      BL       LedToggle
    475                LedToggle((LedNumberType)(6));
   \   000000DE   0x2006             MOVS     R0,#+6
   \   000000E0   0x.... 0x....      BL       LedToggle
    476                LedToggle((LedNumberType)(7));
   \   000000E4   0x2007             MOVS     R0,#+7
   \   000000E6   0x.... 0x....      BL       LedToggle
    477                LedToggle((LedNumberType)(8));
   \   000000EA   0x2008             MOVS     R0,#+8
   \   000000EC   0x.... 0x....      BL       LedToggle
    478                LedToggle((LedNumberType)(0 + U8_AWAY_POSITION_OFFSET));
   \   000000F0   0x2009             MOVS     R0,#+9
   \   000000F2   0x.... 0x....      BL       LedToggle
    479                LedToggle((LedNumberType)(1 + U8_AWAY_POSITION_OFFSET));
   \   000000F6   0x200A             MOVS     R0,#+10
   \   000000F8   0x.... 0x....      BL       LedToggle
    480                LedToggle((LedNumberType)(2 + U8_AWAY_POSITION_OFFSET));
   \   000000FC   0x200B             MOVS     R0,#+11
   \   000000FE   0x.... 0x....      BL       LedToggle
    481                LedToggle((LedNumberType)(3 + U8_AWAY_POSITION_OFFSET));
   \   00000102   0x200C             MOVS     R0,#+12
   \   00000104   0x.... 0x....      BL       LedToggle
    482                LedToggle((LedNumberType)(5 + U8_AWAY_POSITION_OFFSET));
   \   00000108   0x200E             MOVS     R0,#+14
   \   0000010A   0x.... 0x....      BL       LedToggle
    483                LedToggle((LedNumberType)(6 + U8_AWAY_POSITION_OFFSET));
   \   0000010E   0x200F             MOVS     R0,#+15
   \   00000110   0x.... 0x....      BL       LedToggle
    484                LedToggle((LedNumberType)(7 + U8_AWAY_POSITION_OFFSET));
   \   00000114   0x2010             MOVS     R0,#+16
   \   00000116   0x.... 0x....      BL       LedToggle
    485                LedToggle((LedNumberType)(8 + U8_AWAY_POSITION_OFFSET));
   \   0000011A   0x2011             MOVS     R0,#+17
   \   0000011C   0x.... 0x....      BL       LedToggle
    486              }
    487            }
    488            
    489            // Check if any button was pressed and return to initialized state.
    490            for (u8 u8Button = 0; u8Button < TOTAL_BUTTONS; u8Button++)
   \                     ??AntttSM_Gameover_0: (+1)
   \   00000120   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Gameover_9: (+1)
   \   00000122   0xB2E4             UXTB     R4,R4
   \   00000124   0x2C09             CMP      R4,#+9
   \   00000126   0xDA0E             BGE      ??AntttSM_Gameover_10
    491            {
    492              if (WasButtonPressed(u8Button))
   \   00000128   0xB2E4             UXTB     R4,R4
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       WasButtonPressed
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD006             BEQ      ??AntttSM_Gameover_11
    493              {
    494                AntttInitialize();
   \   00000134   0x.... 0x....      BL       AntttInitialize
    495                ButtonAcknowledge(u8Button);
   \   00000138   0xB2E4             UXTB     R4,R4
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       ButtonAcknowledge
    496                return;
   \   00000140   0xE001             B        ??AntttSM_Gameover_12
    497              }
    498            }
   \                     ??AntttSM_Gameover_11: (+1)
   \   00000142   0x1C64             ADDS     R4,R4,#+1
   \   00000144   0xE7ED             B        ??AntttSM_Gameover_9
    499            
    500          } /* end AntttSM_Gameover() */
   \                     ??AntttSM_Gameover_10: (+1)
   \                     ??AntttSM_Gameover_12: (+1)
   \   00000146   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x5000050C         DC32     0x5000050c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x50000504         DC32     0x50000504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x50000508         DC32     0x50000508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     Anttt_u8RxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     Anttt_u16HomeState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Anttt_u16AwayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     AntttSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     ANTTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     Anttt_bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     au16WinningCombos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     Anttt_u8RxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     G_u32BPEngenuicsFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     AntttSM_Wait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     AntttSM_Gameover

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     AntttSM_Active

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Anttt_bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Anttt_u16HomeState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Anttt_u16AwayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     ANTTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    501          
    502          
    503          
    504          /*--------------------------------------------------------------------------------------------------------------------*/
    505          /* End of File                                                                                                        */
    506          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AntttHandleIncomingMessage
        16   -> __aeabi_memcpy
      16   AntttIncomingMessage
        16   -> __aeabi_memcpy
       8   AntttInitialize
         8   -> Anttt_reset_rx_buffer
         8   -> LedOff
         8   -> LedOn
         8   -> nrf_gpio_pin_clear
       4   AntttIsGameOver
      16   AntttSM_Active
        16   -> AntttInitialize
        16   -> AntttIsGameOver
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
      16   AntttSM_Gameover
        16   -> AntttInitialize
        16   -> ButtonAcknowledge
        16   -> LedToggle
        16   -> WasButtonPressed
        16   -> nrf_gpio_pin_toggle
        16 __aeabi_uidivmod
       8   AntttSM_Idle
         8   -> ButtonInitialize
         8   -> LedOn
      16   AntttSM_Wait
        16   -> AntttInitialize
        16   -> AntttIsGameOver
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
      24   Anttt_reset_rx_buffer
        24   -> SystemEnterCriticalSection
        24   -> SystemExitCriticalSection
        24   -> __aeabi_memset
       0   nrf_gpio_pin_clear
       4   nrf_gpio_pin_toggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ?_0
       4  ANTTT_SM
      28  AntttHandleIncomingMessage
      28  AntttIncomingMessage
      76  AntttInitialize
     162  AntttIsGameOver
     248  AntttSM_Active
     328  AntttSM_Gameover
      28  AntttSM_Idle
     228  AntttSM_Wait
       1  Anttt_bPendingResponse
      36  Anttt_reset_rx_buffer
       2  Anttt_u16AwayState
       2  Anttt_u16HomeState
       4  Anttt_u8RxData
       4  G_u32AntttFlags
      16  au16WinningCombos
      10  nrf_gpio_pin_clear
      34  nrf_gpio_pin_toggle

 
    17 bytes in section .bss
    16 bytes in section .data
     4 bytes in section .rodata
 1 290 bytes in section .text
 
 1 290 bytes of CODE  memory
     4 bytes of CONST memory
    33 bytes of DATA  memory

Errors: none
Warnings: none
