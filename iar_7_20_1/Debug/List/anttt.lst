###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        30/May/2018  13:45:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\application\anttt.c
#    Command line =  
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\application\anttt.c
#        -D NRF51 -lC
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\Debug\List\
#        -o
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\application\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\
#        -I
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\
#        -On --require_prototypes -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\Debug\List\anttt.lst
#    Object file  =  
#        C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\iar_7_20_1\Debug\Obj\anttt.o
#
###############################################################################

C:\Users\ENGENUICS5\Documents\GitHub\SummerCamp2018_RC_Car\application\anttt.c
      1          /**********************************************************************************************************************
      2          File: anttt.c                                                                
      3          
      4          Description:
      5          Implements TIC-TAC-TOE using data input from ANT or BLE.
      6          
      7          
      8          **********************************************************************************************************************/
      9          
     10          
     11          
     12          
     13          
     14          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_clear(uint32_t)
   \                     nrf_gpio_pin_clear: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable8  ;; 0x5000050c
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_toggle(uint32_t)
   \                     nrf_gpio_pin_toggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4081             LSLS     R1,R1,R0
   \   00000006   0x....             LDR      R2,??DataTable8_1  ;; 0x50000504
   \   00000008   0x6813             LDR      R3,[R2, #+0]
   \   0000000A   0x40C3             LSRS     R3,R3,R0
   \   0000000C   0x001A             MOVS     R2,R3
   \   0000000E   0x07D2             LSLS     R2,R2,#+31       ;; ZeroExtS R2,R2,#+31,#+31
   \   00000010   0x0FD2             LSRS     R2,R2,#+31
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD102             BNE      ??nrf_gpio_pin_toggle_0
   \   00000016   0x....             LDR      R3,??DataTable8_2  ;; 0x50000508
   \   00000018   0x6019             STR      R1,[R3, #+0]
   \   0000001A   0xE001             B        ??nrf_gpio_pin_toggle_1
   \                     ??nrf_gpio_pin_toggle_0: (+1)
   \   0000001C   0x....             LDR      R3,??DataTable8  ;; 0x5000050c
   \   0000001E   0x6019             STR      R1,[R3, #+0]
   \                     ??nrf_gpio_pin_toggle_1: (+1)
   \   00000020   0xBD00             POP      {PC}             ;; return
     15          
     16          /***********************************************************************************************************************
     17          Global variable definitions with scope across entire project.
     18          All Global variable names shall start with "G_xxAnttt"
     19          ***********************************************************************************************************************/
     20          /* New variables */

   \                                 In section .bss, align 4
     21          u32 G_u32AntttFlags;                                     /* Global state flags */
   \                     G_u32AntttFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     22          fnCode_type ANTTT_SM;
   \                     ANTTT_SM:
   \   00000000                      DS8 4
     23          
     24          /*--------------------------------------------------------------------------------------------------------------------*/
     25          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     26          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     27          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     28          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     29          extern volatile u32 G_u32BPEngenuicsFlags;             /* From bleperipheral_engenuics.c  */
     30          
     31          
     32          /***********************************************************************************************************************
     33          Global variable definitions with scope limited to this local application.
     34          Variable names shall start with "Anttt_<type>" and be declared as static.
     35          ***********************************************************************************************************************/
     36          //static u32 Anttt_u32Timeout;                             /* Timeout counter used across states */
     37          //static u32 Anttt_u32CyclePeriod;                         /* Current base time for Anttt modulation */

   \                                 In section .bss, align 4
     38          static u8 Anttt_u8RxData[ANTTT_COMMAND_SIZE];
   \                     Anttt_u8RxData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     39          static u16 Anttt_u16HomeState;
   \                     Anttt_u16HomeState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     40          static u16 Anttt_u16AwayState;
   \                     Anttt_u16AwayState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     41          static bool Anttt_bPendingResponse;
   \                     Anttt_bPendingResponse:
   \   00000000                      DS8 1
     42          

   \                                 In section .data, align 4
     43          u16 au16WinningCombos[] = 
   \                     au16WinningCombos:
   \   00000000   0x0007 0x0038      DC16 7, 56, 448, 73, 146, 292, 273, 84
   \              0x01C0 0x0049
   \              0x0092 0x0124
   \              0x0111 0x0054
     44          {
     45            0x0007,        // 0b000000111
     46            0x0038,        // 0b000111000
     47            0x01C0,        // 0b111000000
     48            0x0049,        // 0b001001001
     49            0x0092,        // 0b010010010
     50            0x0124,        // 0b100100100
     51            0x0111,        // 0b100010001
     52            0x0054         // 0b001010100
     53          };
     54          
     55          
     56          
     57          /**********************************************************************************************************************
     58          Function Definitions
     59          **********************************************************************************************************************/
     60          
     61          /*--------------------------------------------------------------------------------------------------------------------*/
     62          /* Public functions                                                                                                   */
     63          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     64          void AntttIncomingMessage(u8* pu8Data_, u8 u8Length_)
     65          {
   \                     AntttIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     66            // Check length of the Command Size.
     67            if (u8Length_ != ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttIncomingMessage_0
     68            {
     69              return;
     70            }
     71            
     72            memcpy(Anttt_u8RxData, pu8Data_, u8Length_);
   \                     ??AntttIncomingMessage_1: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable8_3
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
     73          }
   \                     ??AntttIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
     74          
     75          
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          /* Protected functions                                                                                                */
     78          /*--------------------------------------------------------------------------------------------------------------------*/
     79          
     80          /*--------------------------------------------------------------------------------------------------------------------
     81          Function: AntttInitialize
     82          
     83          Description:
     84          Initializes the State Machine and its variables.
     85          
     86          Requires:
     87          
     88          Promises:
     89          */

   \                                 In section .text, align 2, keep-with-next
     90          void AntttInitialize(void)
     91          {
   \                     AntttInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     92            Anttt_reset_rx_buffer();
   \   00000002   0x.... 0x....      BL       Anttt_reset_rx_buffer
     93            Anttt_u16HomeState = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable8_4
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
     94            Anttt_u16AwayState = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR      R1,??DataTable8_5
   \   00000010   0x8008             STRH     R0,[R1, #+0]
     95            ANTTT_SM = &AntttSM_Idle;
   \   00000012   0x....             LDR      R0,??DataTable8_6
   \   00000014   0x....             LDR      R1,??DataTable8_7
   \   00000016   0x6008             STR      R0,[R1, #+0]
     96            Anttt_bPendingResponse = false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR      R1,??DataTable8_8
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
     97            
     98            // Set up initial LEDs.
     99            LedOn(STATUS_RED);
   \   0000001E   0x2012             MOVS     R0,#+18
   \   00000020   0x.... 0x....      BL       LedOn
    100            LedOff(STATUS_YLW);
   \   00000024   0x2013             MOVS     R0,#+19
   \   00000026   0x.... 0x....      BL       LedOff
    101            LedOff(STATUS_GRN);
   \   0000002A   0x2014             MOVS     R0,#+20
   \   0000002C   0x.... 0x....      BL       LedOff
    102            
    103            for (u8 u8Led = 0; u8Led < (TOTAL_BUTTONS * 2); u8Led++)
   \   00000030   0x2400             MOVS     R4,#+0
   \                     ??AntttInitialize_0: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4
   \   00000034   0x2C12             CMP      R4,#+18
   \   00000036   0xDA05             BGE      ??AntttInitialize_1
    104            {
    105              LedOff((LedNumberType) u8Led);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       LedOff
    106            }
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \   00000042   0xE7F6             B        ??AntttInitialize_0
    107            
    108            nrf_gpio_pin_clear(16);
   \                     ??AntttInitialize_1: (+1)
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0x.... 0x....      BL       nrf_gpio_pin_clear
    109            
    110          } /* end AntttInitialize() */
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    111          
    112          
    113          /*--------------------------------------------------------------------------------------------------------------------
    114          Function: AntttHandleIncomingMessage(u8* pu8Data_, u8 u8Length_)
    115          
    116          Description:
    117          Copies incoming data to the Anttt Rx buffer.
    118          
    119          Requires:
    120          - pu8Data_ points to the data string
    121          - u8Length_ is the size of the data
    122          
    123          Promises:
    124          - Anttt_u8RxData is filled with pu8Data_ if length is correct;
    125            otherwise does nothing.
    126          */

   \                                 In section .text, align 2, keep-with-next
    127          void AntttHandleIncomingMessage(u8* pu8Data_, u8 u8Length_)
    128          {
   \                     AntttHandleIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    129            // Check the appropriate length.
    130            if (u8Length_ == ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttHandleIncomingMessage_0
    131            {
    132              memcpy(Anttt_u8RxData, pu8Data_, u8Length_);
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable9
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    133            }
    134          }
   \                     ??AntttHandleIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    135          
    136          
    137          /*--------------------------------------------------------------------------------------------------------------------*/
    138          /* Private functions                                                                                                  */
    139          /*--------------------------------------------------------------------------------------------------------------------*/
    140          
    141          /*--------------------------------------------------------------------------------------------------------------------
    142          Function: static bool AntttIsGameOver(void)
    143          
    144          Description:
    145          Check to see how a game has ended
    146          
    147          Requires:
    148          - Anttt_u16HomeState holds the game data for the "home" team
    149          - Anttt_u16AwayState holds the game data for the "away" team
    150          
    151          Promises:
    152          - Anttt_u8RxData is filled with pu8Data_ if length is correct;
    153            otherwise does nothing.
    154          */

   \                                 In section .text, align 2, keep-with-next
    155          static bool AntttIsGameOver(void)
    156          {
   \                     AntttIsGameOver: (+1)
   \   00000000   0xB500             PUSH     {LR}
    157            // Check all 8 winning combinations.
    158            for (u8 i = 0; i < 8; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \                     ??AntttIsGameOver_0: (+1)
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2808             CMP      R0,#+8
   \   00000008   0xDA3F             BGE      ??AntttIsGameOver_1
    159            {
    160              if ((Anttt_u16HomeState & au16WinningCombos[i]) == au16WinningCombos[i])
   \   0000000A   0x....             LDR      R1,??DataTable8_4
   \   0000000C   0x8809             LDRH     R1,[R1, #+0]
   \   0000000E   0x....             LDR      R2,??DataTable8_9
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x4343             MULS     R3,R0,R3
   \   00000016   0x5AD2             LDRH     R2,[R2, R3]
   \   00000018   0x400A             ANDS     R2,R2,R1
   \   0000001A   0x....             LDR      R1,??DataTable8_9
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2302             MOVS     R3,#+2
   \   00000020   0x4343             MULS     R3,R0,R3
   \   00000022   0x5AC9             LDRH     R1,[R1, R3]
   \   00000024   0x428A             CMP      R2,R1
   \   00000026   0xD10F             BNE      ??AntttIsGameOver_2
    161              {
    162                Anttt_u16HomeState  = au16WinningCombos[i];
   \   00000028   0x....             LDR      R1,??DataTable8_9
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x4350             MULS     R0,R2,R0
   \   00000030   0x5A08             LDRH     R0,[R1, R0]
   \   00000032   0x....             LDR      R1,??DataTable8_4
   \   00000034   0x8008             STRH     R0,[R1, #+0]
    163                Anttt_u16HomeState |= _U16_ANTTT_WIN_FLAG;       // Set this flag to indicate home won.
   \   00000036   0x....             LDR      R0,??DataTable8_4
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000003E   0x4301             ORRS     R1,R1,R0
   \   00000040   0x....             LDR      R0,??DataTable8_4
   \   00000042   0x8001             STRH     R1,[R0, #+0]
    164                
    165                return true;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE02B             B        ??AntttIsGameOver_3
    166              }
    167              else if ( (Anttt_u16AwayState & au16WinningCombos[i]) == au16WinningCombos[i])
   \                     ??AntttIsGameOver_2: (+1)
   \   00000048   0x....             LDR      R1,??DataTable8_5
   \   0000004A   0x8809             LDRH     R1,[R1, #+0]
   \   0000004C   0x....             LDR      R2,??DataTable8_9
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x2302             MOVS     R3,#+2
   \   00000052   0x4343             MULS     R3,R0,R3
   \   00000054   0x5AD2             LDRH     R2,[R2, R3]
   \   00000056   0x400A             ANDS     R2,R2,R1
   \   00000058   0x....             LDR      R1,??DataTable8_9
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x2302             MOVS     R3,#+2
   \   0000005E   0x4343             MULS     R3,R0,R3
   \   00000060   0x5AC9             LDRH     R1,[R1, R3]
   \   00000062   0x428A             CMP      R2,R1
   \   00000064   0xD10F             BNE      ??AntttIsGameOver_4
    168              {
    169                Anttt_u16AwayState = au16WinningCombos[i];
   \   00000066   0x....             LDR      R1,??DataTable8_9
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0x2202             MOVS     R2,#+2
   \   0000006C   0x4350             MULS     R0,R2,R0
   \   0000006E   0x5A08             LDRH     R0,[R1, R0]
   \   00000070   0x....             LDR      R1,??DataTable8_5
   \   00000072   0x8008             STRH     R0,[R1, #+0]
    170                Anttt_u16AwayState |= _U16_ANTTT_WIN_FLAG;       // Set this flag to indicate away winning won.
   \   00000074   0x....             LDR      R0,??DataTable8_5
   \   00000076   0x8800             LDRH     R0,[R0, #+0]
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000007C   0x4301             ORRS     R1,R1,R0
   \   0000007E   0x....             LDR      R0,??DataTable8_5
   \   00000080   0x8001             STRH     R1,[R0, #+0]
    171                
    172                return true;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE00C             B        ??AntttIsGameOver_3
    173              }
    174            }
   \                     ??AntttIsGameOver_4: (+1)
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0xE7BC             B        ??AntttIsGameOver_0
    175            
    176            // Check if draw.
    177            if ((Anttt_u16HomeState | Anttt_u16AwayState) == U16_ANTTT_DRAW)
   \                     ??AntttIsGameOver_1: (+1)
   \   0000008A   0x....             LDR      R0,??DataTable8_4
   \   0000008C   0x8800             LDRH     R0,[R0, #+0]
   \   0000008E   0x....             LDR      R1,??DataTable8_5
   \   00000090   0x8809             LDRH     R1,[R1, #+0]
   \   00000092   0x4301             ORRS     R1,R1,R0
   \   00000094   0x....             LDR      R0,??DataTable9_1  ;; 0x1ff
   \   00000096   0x4281             CMP      R1,R0
   \   00000098   0xD101             BNE      ??AntttIsGameOver_5
    178            {
    179              return true;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE000             B        ??AntttIsGameOver_3
    180            }
    181            
    182            return false;
   \                     ??AntttIsGameOver_5: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??AntttIsGameOver_3: (+1)
   \   000000A0   0xBD00             POP      {PC}             ;; return
    183          }
    184          
    185          
    186          /*--------------------------------------------------------------------------------------------------------------------
    187          Function: static void Anttt_reset_rx_buffer(void)
    188          
    189          Description:
    190          Clear the Rx buffer
    191          
    192          Requires:
    193          - 
    194          
    195          Promises:
    196          - Anttt_u8RxData is filled with 0xFF
    197          */

   \                                 In section .text, align 2, keep-with-next
    198          static void Anttt_reset_rx_buffer(void)
    199          {
   \                     Anttt_reset_rx_buffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    200            u8 u8Status;
    201            
    202            SystemEnterCriticalSection(&u8Status);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       SystemEnterCriticalSection
    203            memset(Anttt_u8RxData, 0xFF, ANTTT_COMMAND_SIZE);   
   \   0000000A   0x2503             MOVS     R5,#+3
   \   0000000C   0x24FF             MOVS     R4,#+255
   \   0000000E   0x....             LDR      R6,??DataTable9
   \   00000010   0x0022             MOVS     R2,R4
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memset
    204            SystemExitCriticalSection(u8Status);
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       SystemExitCriticalSection
    205          }
   \   00000022   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    206          
    207          
    208          /*--------------------------------------------------------------------------------------------------------------------*/
    209          /* State Machine definitions                                                                                          */
    210          /*--------------------------------------------------------------------------------------------------------------------*/
    211          
    212          /*--------------------------------------------------------------------------------------------------------------------
    213          State: AntttSM_Idle
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          static void AntttSM_Idle(void)
    216          {
   \                     AntttSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    217            // Check if module is connected to client.
    218            if (G_u32BPEngenuicsFlags == _BPENGENUICS_CONNECTED)
   \   00000002   0x....             LDR      R0,??DataTable9_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD107             BNE      ??AntttSM_Idle_0
    219            {
    220              // Set LEDs and proceed to wait state.
    221              LedOn(STATUS_GRN);   // Connected to Client.
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0x.... 0x....      BL       LedOn
    222              
    223              // Reset any pending button states incase the user was pressing while waiting.
    224              ButtonInitialize();
   \   00000010   0x.... 0x....      BL       ButtonInitialize
    225              
    226              ANTTT_SM = &AntttSM_Wait;
   \   00000014   0x....             LDR      R0,??DataTable9_3
   \   00000016   0x....             LDR      R1,??DataTable8_7
   \   00000018   0x6008             STR      R0,[R1, #+0]
    227            }
    228            
    229          #if 0
    230            /* TEST CODE TO TEST BUTTONS */
    231            for (u8 i = 0; i < TOTAL_BUTTONS; i++)
    232            {
    233             if (WasButtonPressed(i))
    234             {
    235               LedToggle(0xFF);
    236               ButtonAcknowledge(i);
    237               return;
    238             }
    239            }
    240          #endif
    241            
    242          } 
   \                     ??AntttSM_Idle_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    243          
    244          /*--------------------------------------------------------------------------------------------------------------------
    245          State: AntttSM_Wait
    246          Wait for the other player to make a move.
    247          */

   \                                 In section .text, align 2, keep-with-next
    248          static void AntttSM_Wait(void)
    249          {
   \                     AntttSM_Wait: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    250            u8 au8Temp[ANTTT_COMMAND_SIZE] = {0, 0, 0};
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #0]
    251            u8 u8Position;
    252            
    253            // Check if module has established connection with client.
    254            if (G_u32BPEngenuicsFlags & _BPENGENUICS_CONNECTED)
   \   00000008   0x....             LDR      R0,??DataTable9_2
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD554             BPL      ??AntttSM_Wait_0
    255            {
    256              // Wait for Client to make a move.
    257              if (Anttt_u8RxData[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE)
   \   00000010   0x....             LDR      R0,??DataTable8_3
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x28CC             CMP      R0,#+204
   \   00000016   0xD152             BNE      ??AntttSM_Wait_1
    258              {
    259                u8Position = Anttt_u8RxData[ANTTT_COMMAND_POSITION_OFFSET];
   \   00000018   0x....             LDR      R0,??DataTable8_3
   \   0000001A   0x7840             LDRB     R0,[R0, #+1]
   \   0000001C   0x0004             MOVS     R4,R0
    260                      
    261                // Check if position is already chosen or incorrect position sent.
    262                if ( (Anttt_u16HomeState & (1 << u8Position)) || 
    263                     (Anttt_u16AwayState & (1 << u8Position)) ||
    264                     (u8Position >= TOTAL_BUTTONS) )
   \   0000001E   0x....             LDR      R0,??DataTable8_4
   \   00000020   0x8800             LDRH     R0,[R0, #+0]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x40A1             LSLS     R1,R1,R4
   \   00000026   0x4208             TST      R0,R1
   \   00000028   0xD108             BNE      ??AntttSM_Wait_2
   \   0000002A   0x....             LDR      R0,??DataTable8_5
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x40A1             LSLS     R1,R1,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD102             BNE      ??AntttSM_Wait_2
   \   00000036   0xB2E4             UXTB     R4,R4
   \   00000038   0x2C09             CMP      R4,#+9
   \   0000003A   0xDB07             BLT      ??AntttSM_Wait_3
    265                {
    266                  // Send NACK response.
    267                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_NACK;
   \                     ??AntttSM_Wait_2: (+1)
   \   0000003C   0x20BC             MOVS     R0,#+188
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    268                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       BPEngenuicsSendData
   \   0000004A   0xE033             B        ??AntttSM_Wait_4
    269                }
    270                else
    271                {
    272                  // New Position.
    273                  LedOn((LedNumberType) (u8Position + U8_AWAY_POSITION_OFFSET));  
   \                     ??AntttSM_Wait_3: (+1)
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x3009             ADDS     R0,R0,#+9
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x.... 0x....      BL       LedOn
    274                  Anttt_u16AwayState |= 1 << (u8Position);
   \   00000056   0x....             LDR      R0,??DataTable8_5
   \   00000058   0x8800             LDRH     R0,[R0, #+0]
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x40A1             LSLS     R1,R1,R4
   \   0000005E   0x4301             ORRS     R1,R1,R0
   \   00000060   0x....             LDR      R0,??DataTable8_5
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    275                  
    276                  // Send response.
    277                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_ACK;
   \   00000064   0x20AC             MOVS     R0,#+172
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    278                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       BPEngenuicsSendData
    279                  
    280                  // Check if game is over.
    281                  if (AntttIsGameOver())
   \   00000072   0x.... 0x....      BL       AntttIsGameOver
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD016             BEQ      ??AntttSM_Wait_5
    282                  {
    283                    // Set up initial LEDs.
    284                    LedOff(STATUS_RED);
   \   0000007A   0x2012             MOVS     R0,#+18
   \   0000007C   0x.... 0x....      BL       LedOff
    285                    LedOff(STATUS_YLW);
   \   00000080   0x2013             MOVS     R0,#+19
   \   00000082   0x.... 0x....      BL       LedOff
    286                    LedOff(STATUS_GRN);
   \   00000086   0x2014             MOVS     R0,#+20
   \   00000088   0x.... 0x....      BL       LedOff
    287              
    288                    for (u8 i = 0; i < (TOTAL_BUTTONS * 2); i++)
   \   0000008C   0x2500             MOVS     R5,#+0
   \                     ??AntttSM_Wait_6: (+1)
   \   0000008E   0xB2ED             UXTB     R5,R5
   \   00000090   0x2D12             CMP      R5,#+18
   \   00000092   0xDA05             BGE      ??AntttSM_Wait_7
    289                    {
    290                      LedOff((LedNumberType) i);
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x.... 0x....      BL       LedOff
    291                    }
   \   0000009C   0x1C6D             ADDS     R5,R5,#+1
   \   0000009E   0xE7F6             B        ??AntttSM_Wait_6
    292                    
    293                    ANTTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Wait_7: (+1)
   \   000000A0   0x....             LDR      R0,??DataTable10
   \   000000A2   0x....             LDR      R1,??DataTable8_7
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    294                    return;
   \   000000A6   0xE01C             B        ??AntttSM_Wait_8
    295                  }
    296          
    297                  // Update State.
    298                  ANTTT_SM = &AntttSM_Active;
   \                     ??AntttSM_Wait_5: (+1)
   \   000000A8   0x....             LDR      R0,??DataTable10_1
   \   000000AA   0x....             LDR      R1,??DataTable8_7
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    299                  LedOn(STATUS_YLW);
   \   000000AE   0x2013             MOVS     R0,#+19
   \   000000B0   0x.... 0x....      BL       LedOn
    300                }
    301                
    302                /* Regardless, clear the Rx buffer */
    303                Anttt_reset_rx_buffer();
   \                     ??AntttSM_Wait_4: (+1)
   \   000000B4   0x.... 0x....      BL       Anttt_reset_rx_buffer
   \   000000B8   0xE001             B        ??AntttSM_Wait_1
    304                
    305              }
    306            } /* end if (G_u32BPEngenuicsFlags & _BPENGENUICS_CONNECTED) */
    307            else
    308            {
    309              // Disconnected from client.
    310              AntttInitialize();
   \                     ??AntttSM_Wait_0: (+1)
   \   000000BA   0x.... 0x....      BL       AntttInitialize
    311            }
    312            
    313            // User may be pressing buttons in this state, Ack the button presses to 
    314            // disable queuing of the presses as valid game presses.
    315            for (u32 u32Button = 0; u32Button < TOTAL_BUTTONS; u32Button++)
   \                     ??AntttSM_Wait_1: (+1)
   \   000000BE   0x2500             MOVS     R5,#+0
   \                     ??AntttSM_Wait_9: (+1)
   \   000000C0   0x2D09             CMP      R5,#+9
   \   000000C2   0xD20E             BCS      ??AntttSM_Wait_10
    316            {
    317              if (WasButtonPressed(u32Button) & !Anttt_bPendingResponse)
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0x.... 0x....      BL       WasButtonPressed
   \   000000CA   0x....             LDR      R1,??DataTable10_2
   \   000000CC   0x7809             LDRB     R1,[R1, #+0]
   \   000000CE   0x2201             MOVS     R2,#+1
   \   000000D0   0x404A             EORS     R2,R2,R1
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x4210             TST      R0,R2
   \   000000D6   0xD002             BEQ      ??AntttSM_Wait_11
    318              {
    319                ButtonAcknowledge(u32Button);  
   \   000000D8   0x0028             MOVS     R0,R5
   \   000000DA   0x.... 0x....      BL       ButtonAcknowledge
    320              }
    321            }
   \                     ??AntttSM_Wait_11: (+1)
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
   \   000000E0   0xE7EE             B        ??AntttSM_Wait_9
    322          }
   \                     ??AntttSM_Wait_10: (+1)
   \                     ??AntttSM_Wait_8: (+1)
   \   000000E2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    323          
    324          /*--------------------------------------------------------------------------------------------------------------------
    325          State: AntttSM_Active
    326          Local player makes a move
    327          */

   \                                 In section .text, align 2, keep-with-next
    328          static void AntttSM_Active(void)
    329          {
   \                     AntttSM_Active: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    330            // Check if module has established connection with client.
    331            if (G_u32BPEngenuicsFlags & _BPENGENUICS_SERVICE_ENABLED)
   \   00000004   0x....             LDR      R0,??DataTable9_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD572             BPL      ??AntttSM_Active_0
    332            {
    333              // Make a move.
    334              // Check if a button was pressed, then update UI and send message.  
    335              for (u8 u8Button = 0; u8Button < TOTAL_BUTTONS; u8Button++)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_1: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4
   \   00000010   0x2C09             CMP      R4,#+9
   \   00000012   0xDA43             BGE      ??AntttSM_Active_2
    336              {
    337                if (WasButtonPressed(u8Button) & !Anttt_bPendingResponse)
   \   00000014   0xB2E4             UXTB     R4,R4
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       WasButtonPressed
   \   0000001C   0x....             LDR      R1,??DataTable10_2
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x404A             EORS     R2,R2,R1
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x4210             TST      R0,R2
   \   00000028   0xD02E             BEQ      ??AntttSM_Active_3
    338                {
    339                  u8 au8Temp[ANTTT_COMMAND_SIZE];
    340                  
    341                  // Check if a valid press. Check if position already chosen via client
    342                  // or itself or incorrect button index reported
    343                  if ( (Anttt_u16HomeState & (1 << u8Button)) || 
    344                       (Anttt_u16AwayState & (1 << u8Button)) ||
    345                       (u8Button >= TOTAL_BUTTONS))
   \   0000002A   0x....             LDR      R0,??DataTable10_3
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x40A1             LSLS     R1,R1,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD108             BNE      ??AntttSM_Active_4
   \   00000036   0x....             LDR      R0,??DataTable10_4
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x40A1             LSLS     R1,R1,R4
   \   0000003E   0x4208             TST      R0,R1
   \   00000040   0xD102             BNE      ??AntttSM_Active_4
   \   00000042   0xB2E4             UXTB     R4,R4
   \   00000044   0x2C09             CMP      R4,#+9
   \   00000046   0xDB00             BLT      ??AntttSM_Active_5
    346                  {
    347                    continue;
   \                     ??AntttSM_Active_4: (+1)
   \   00000048   0xE026             B        ??AntttSM_Active_6
    348                  }
    349                  
    350                  // Button index directly corresponds to Home LED Index.
    351                  // First Update UI.
    352                  LedOn((LedNumberType) u8Button);
   \                     ??AntttSM_Active_5: (+1)
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       LedOn
    353                  Anttt_u16HomeState |= 1 << (u8Button);
   \   00000052   0x....             LDR      R0,??DataTable10_3
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x40A1             LSLS     R1,R1,R4
   \   0000005A   0x4301             ORRS     R1,R1,R0
   \   0000005C   0x....             LDR      R0,??DataTable10_3
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
    354                  
    355                  // Send message to client.
    356                  au8Temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE;
   \   00000060   0x20CC             MOVS     R0,#+204
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    357                  au8Temp[ANTTT_COMMAND_POSITION_OFFSET] = u8Button;
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7044             STRB     R4,[R0, #+1]
    358                  au8Temp[ANTTT_COMMAND_SOURCE_OFFSET] = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x7088             STRB     R0,[R1, #+2]
    359                  BPEngenuicsSendData(au8Temp, ANTTT_COMMAND_SIZE);
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x.... 0x....      BL       BPEngenuicsSendData
    360                  
    361                  ButtonAcknowledge(u8Button);   
   \   00000078   0xB2E4             UXTB     R4,R4
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       ButtonAcknowledge
    362                  Anttt_bPendingResponse = true;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x....             LDR      R1,??DataTable10_2
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    363                  return;
   \   00000086   0xE036             B        ??AntttSM_Active_7
    364                }
    365                else if (Anttt_bPendingResponse)
   \                     ??AntttSM_Active_3: (+1)
   \   00000088   0x....             LDR      R0,??DataTable10_2
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD003             BEQ      ??AntttSM_Active_6
    366                {
    367                  // User may be pressing buttons in this state, Ack the button presses to 
    368                  // disable queuing of the presses as valid game presses.
    369                  ButtonAcknowledge(u8Button);    
   \   00000090   0xB2E4             UXTB     R4,R4
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       ButtonAcknowledge
    370                }
    371              }
   \                     ??AntttSM_Active_6: (+1)
   \   00000098   0x1C64             ADDS     R4,R4,#+1
   \   0000009A   0xE7B8             B        ??AntttSM_Active_1
    372              
    373              // Check if response received.
    374              if (Anttt_u8RxData[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE_ACK)
   \                     ??AntttSM_Active_2: (+1)
   \   0000009C   0x....             LDR      R0,??DataTable9
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x28AC             CMP      R0,#+172
   \   000000A2   0xD128             BNE      ??AntttSM_Active_8
    375              {
    376                Anttt_reset_rx_buffer();
   \   000000A4   0x.... 0x....      BL       Anttt_reset_rx_buffer
    377                Anttt_bPendingResponse = false;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x....             LDR      R1,??DataTable10_2
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    378                
    379                // Check if game is over.
    380                if (AntttIsGameOver())
   \   000000AE   0x.... 0x....      BL       AntttIsGameOver
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD016             BEQ      ??AntttSM_Active_9
    381                {
    382                  // Set up initial LEDs.
    383                  LedOff(STATUS_RED);
   \   000000B6   0x2012             MOVS     R0,#+18
   \   000000B8   0x.... 0x....      BL       LedOff
    384                  LedOff(STATUS_YLW);
   \   000000BC   0x2013             MOVS     R0,#+19
   \   000000BE   0x.... 0x....      BL       LedOff
    385                  LedOff(STATUS_GRN);
   \   000000C2   0x2014             MOVS     R0,#+20
   \   000000C4   0x.... 0x....      BL       LedOff
    386            
    387                  for (u8 i = 0; i < (TOTAL_BUTTONS * 2); i++)
   \   000000C8   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_10: (+1)
   \   000000CA   0xB2E4             UXTB     R4,R4
   \   000000CC   0x2C12             CMP      R4,#+18
   \   000000CE   0xDA05             BGE      ??AntttSM_Active_11
    388                  {
    389                    LedOff((LedNumberType) i);
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x.... 0x....      BL       LedOff
    390                  }
   \   000000D8   0x1C64             ADDS     R4,R4,#+1
   \   000000DA   0xE7F6             B        ??AntttSM_Active_10
    391                  
    392                  ANTTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Active_11: (+1)
   \   000000DC   0x....             LDR      R0,??DataTable10
   \   000000DE   0x....             LDR      R1,??DataTable10_5
   \   000000E0   0x6008             STR      R0,[R1, #+0]
    393                  return;
   \   000000E2   0xE008             B        ??AntttSM_Active_7
    394                }
    395                
    396                // Update State.
    397                ANTTT_SM = &AntttSM_Wait;
   \                     ??AntttSM_Active_9: (+1)
   \   000000E4   0x....             LDR      R0,??DataTable9_3
   \   000000E6   0x....             LDR      R1,??DataTable10_5
   \   000000E8   0x6008             STR      R0,[R1, #+0]
    398                LedOff(STATUS_YLW);
   \   000000EA   0x2013             MOVS     R0,#+19
   \   000000EC   0x.... 0x....      BL       LedOff
   \   000000F0   0xE001             B        ??AntttSM_Active_8
    399              }
    400            }
    401            else
    402            {
    403              // Disconnected from client.
    404              AntttInitialize();
   \                     ??AntttSM_Active_0: (+1)
   \   000000F2   0x.... 0x....      BL       AntttInitialize
    405            }
    406          }
   \                     ??AntttSM_Active_8: (+1)
   \                     ??AntttSM_Active_7: (+1)
   \   000000F6   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    407          
    408          
    409          /*--------------------------------------------------------------------------------------------------------------------
    410          State: AntttSM_Gameover
    411          Game ending sequence
    412          */

   \                                 In section .text, align 2, keep-with-next
    413          static void AntttSM_Gameover(void)
    414          {   
   \                     AntttSM_Gameover: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    415            // Play Winning Sequence. 
    416            if ((G_u32SystemTime1ms % 500) == 0)
   \   00000002   0x....             LDR      R0,??DataTable10_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x21FA             MOVS     R1,#+250
   \   00000008   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \   0000000A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD000             BEQ      .+4
   \   00000012   0xE085             B        ??AntttSM_Gameover_0
    417            {
    418              nrf_gpio_pin_toggle(16);
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       nrf_gpio_pin_toggle
    419              
    420              // Toggle LED sequences.
    421              LedToggle(STATUS_GRN);
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x.... 0x....      BL       LedToggle
    422              LedToggle(STATUS_RED);
   \   00000020   0x2012             MOVS     R0,#+18
   \   00000022   0x.... 0x....      BL       LedToggle
    423              LedToggle(STATUS_YLW);
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       LedToggle
    424              
    425              // Blink winning sequence.
    426              if (Anttt_u16HomeState & _U16_ANTTT_WIN_FLAG)
   \   0000002C   0x....             LDR      R0,??DataTable10_3
   \   0000002E   0x8800             LDRH     R0,[R0, #+0]
   \   00000030   0x0580             LSLS     R0,R0,#+22
   \   00000032   0xD51D             BPL      ??AntttSM_Gameover_1
    427              {
    428                // Home won.
    429                u8 au8Three[3];
    430                u8 u8Index = 0;
   \   00000034   0x2400             MOVS     R4,#+0
    431                u16 u16Temp = Anttt_u16HomeState;  
   \   00000036   0x....             LDR      R0,??DataTable10_3
   \   00000038   0x8805             LDRH     R5,[R0, #+0]
    432                
    433                // Convert LED bitmask to LED value.
    434                for (u8 i = 0; i < 9; i++)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_2: (+1)
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x2809             CMP      R0,#+9
   \   00000040   0xDA09             BGE      ??AntttSM_Gameover_3
    435                {
    436                  if (u16Temp & 0x01)
   \   00000042   0x07E9             LSLS     R1,R5,#+31
   \   00000044   0xD503             BPL      ??AntttSM_Gameover_4
    437                  {
    438                    au8Three[u8Index++] = i;
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0xB2E4             UXTB     R4,R4
   \   0000004A   0x5508             STRB     R0,[R1, R4]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
    439                  }
    440                  
    441                  u16Temp = u16Temp >> 1;
   \                     ??AntttSM_Gameover_4: (+1)
   \   0000004E   0xB2AD             UXTH     R5,R5
   \   00000050   0x086D             LSRS     R5,R5,#+1
    442                }
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xE7F2             B        ??AntttSM_Gameover_2
    443                
    444                LedToggle((LedNumberType)au8Three[0]);
   \                     ??AntttSM_Gameover_3: (+1)
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       LedToggle
    445                LedToggle((LedNumberType)au8Three[1]);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x7840             LDRB     R0,[R0, #+1]
   \   00000062   0x.... 0x....      BL       LedToggle
    446                LedToggle((LedNumberType)au8Three[2]);
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7880             LDRB     R0,[R0, #+2]
   \   0000006A   0x.... 0x....      BL       LedToggle
   \   0000006E   0xE057             B        ??AntttSM_Gameover_0
    447              }
    448              else if (Anttt_u16AwayState & _U16_ANTTT_WIN_FLAG)
   \                     ??AntttSM_Gameover_1: (+1)
   \   00000070   0x....             LDR      R0,??DataTable10_4
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x0580             LSLS     R0,R0,#+22
   \   00000076   0xD523             BPL      ??AntttSM_Gameover_5
    449              {
    450                // Away won.
    451                u8 au8Three[3];
    452                u8 u8Index = 0;
   \   00000078   0x2400             MOVS     R4,#+0
    453                u16 u16Temp = Anttt_u16AwayState;  
   \   0000007A   0x....             LDR      R0,??DataTable10_4
   \   0000007C   0x8805             LDRH     R5,[R0, #+0]
    454                
    455                // Convert LED bitmask to LED value.
    456                for (u8 i = 0; i < 9; i++)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_6: (+1)
   \   00000080   0xB2C0             UXTB     R0,R0
   \   00000082   0x2809             CMP      R0,#+9
   \   00000084   0xDA09             BGE      ??AntttSM_Gameover_7
    457                {
    458                  if (u16Temp & 0x01)
   \   00000086   0x07E9             LSLS     R1,R5,#+31
   \   00000088   0xD503             BPL      ??AntttSM_Gameover_8
    459                  {
    460                    au8Three[u8Index++] = i;
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0x5508             STRB     R0,[R1, R4]
   \   00000090   0x1C64             ADDS     R4,R4,#+1
    461                  }
    462                  
    463                  u16Temp = u16Temp >> 1;
   \                     ??AntttSM_Gameover_8: (+1)
   \   00000092   0xB2AD             UXTH     R5,R5
   \   00000094   0x086D             LSRS     R5,R5,#+1
    464                }
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0xE7F2             B        ??AntttSM_Gameover_6
    465                
    466                LedToggle((LedNumberType)(au8Three[0] + 9));
   \                     ??AntttSM_Gameover_7: (+1)
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x3009             ADDS     R0,R0,#+9
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x.... 0x....      BL       LedToggle
    467                LedToggle((LedNumberType)(au8Three[1] + 9));
   \   000000A6   0x4668             MOV      R0,SP
   \   000000A8   0x7840             LDRB     R0,[R0, #+1]
   \   000000AA   0x3009             ADDS     R0,R0,#+9
   \   000000AC   0xB2C0             UXTB     R0,R0
   \   000000AE   0x.... 0x....      BL       LedToggle
    468                LedToggle((LedNumberType)(au8Three[2] + 9));
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x7880             LDRB     R0,[R0, #+2]
   \   000000B6   0x3009             ADDS     R0,R0,#+9
   \   000000B8   0xB2C0             UXTB     R0,R0
   \   000000BA   0x.... 0x....      BL       LedToggle
   \   000000BE   0xE02F             B        ??AntttSM_Gameover_0
    469              }
    470              else
    471              {
    472                // Play Draw Sequence.
    473                LedToggle((LedNumberType)(0));
   \                     ??AntttSM_Gameover_5: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       LedToggle
    474                LedToggle((LedNumberType)(1));
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       LedToggle
    475                LedToggle((LedNumberType)(2));
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0x.... 0x....      BL       LedToggle
    476                LedToggle((LedNumberType)(3));
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x.... 0x....      BL       LedToggle
    477                LedToggle((LedNumberType)(5));
   \   000000D8   0x2005             MOVS     R0,#+5
   \   000000DA   0x.... 0x....      BL       LedToggle
    478                LedToggle((LedNumberType)(6));
   \   000000DE   0x2006             MOVS     R0,#+6
   \   000000E0   0x.... 0x....      BL       LedToggle
    479                LedToggle((LedNumberType)(7));
   \   000000E4   0x2007             MOVS     R0,#+7
   \   000000E6   0x.... 0x....      BL       LedToggle
    480                LedToggle((LedNumberType)(8));
   \   000000EA   0x2008             MOVS     R0,#+8
   \   000000EC   0x.... 0x....      BL       LedToggle
    481                LedToggle((LedNumberType)(0 + U8_AWAY_POSITION_OFFSET));
   \   000000F0   0x2009             MOVS     R0,#+9
   \   000000F2   0x.... 0x....      BL       LedToggle
    482                LedToggle((LedNumberType)(1 + U8_AWAY_POSITION_OFFSET));
   \   000000F6   0x200A             MOVS     R0,#+10
   \   000000F8   0x.... 0x....      BL       LedToggle
    483                LedToggle((LedNumberType)(2 + U8_AWAY_POSITION_OFFSET));
   \   000000FC   0x200B             MOVS     R0,#+11
   \   000000FE   0x.... 0x....      BL       LedToggle
    484                LedToggle((LedNumberType)(3 + U8_AWAY_POSITION_OFFSET));
   \   00000102   0x200C             MOVS     R0,#+12
   \   00000104   0x.... 0x....      BL       LedToggle
    485                LedToggle((LedNumberType)(5 + U8_AWAY_POSITION_OFFSET));
   \   00000108   0x200E             MOVS     R0,#+14
   \   0000010A   0x.... 0x....      BL       LedToggle
    486                LedToggle((LedNumberType)(6 + U8_AWAY_POSITION_OFFSET));
   \   0000010E   0x200F             MOVS     R0,#+15
   \   00000110   0x.... 0x....      BL       LedToggle
    487                LedToggle((LedNumberType)(7 + U8_AWAY_POSITION_OFFSET));
   \   00000114   0x2010             MOVS     R0,#+16
   \   00000116   0x.... 0x....      BL       LedToggle
    488                LedToggle((LedNumberType)(8 + U8_AWAY_POSITION_OFFSET));
   \   0000011A   0x2011             MOVS     R0,#+17
   \   0000011C   0x.... 0x....      BL       LedToggle
    489              }
    490            }
    491            
    492            // Check if any button was pressed and return to initialized state.
    493            for (u8 u8Button = 0; u8Button < TOTAL_BUTTONS; u8Button++)
   \                     ??AntttSM_Gameover_0: (+1)
   \   00000120   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Gameover_9: (+1)
   \   00000122   0xB2E4             UXTB     R4,R4
   \   00000124   0x2C09             CMP      R4,#+9
   \   00000126   0xDA0E             BGE      ??AntttSM_Gameover_10
    494            {
    495              if (WasButtonPressed(u8Button))
   \   00000128   0xB2E4             UXTB     R4,R4
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       WasButtonPressed
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD006             BEQ      ??AntttSM_Gameover_11
    496              {
    497                AntttInitialize();
   \   00000134   0x.... 0x....      BL       AntttInitialize
    498                ButtonAcknowledge(u8Button);
   \   00000138   0xB2E4             UXTB     R4,R4
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       ButtonAcknowledge
    499                return;
   \   00000140   0xE001             B        ??AntttSM_Gameover_12
    500              }
    501            }
   \                     ??AntttSM_Gameover_11: (+1)
   \   00000142   0x1C64             ADDS     R4,R4,#+1
   \   00000144   0xE7ED             B        ??AntttSM_Gameover_9
    502            
    503          } /* end AntttSM_Gameover() */
   \                     ??AntttSM_Gameover_10: (+1)
   \                     ??AntttSM_Gameover_12: (+1)
   \   00000146   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x5000050C         DC32     0x5000050c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x50000504         DC32     0x50000504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x50000508         DC32     0x50000508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     Anttt_u8RxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     Anttt_u16HomeState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Anttt_u16AwayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     AntttSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     ANTTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     Anttt_bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     au16WinningCombos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     Anttt_u8RxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     G_u32BPEngenuicsFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     AntttSM_Wait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     AntttSM_Gameover

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     AntttSM_Active

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Anttt_bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Anttt_u16HomeState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Anttt_u16AwayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     ANTTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    504          
    505          
    506          
    507          
    508          
    509          
    510          
    511          /*--------------------------------------------------------------------------------------------------------------------*/
    512          /* End of File                                                                                                        */
    513          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AntttHandleIncomingMessage
        16   -> __aeabi_memcpy
      16   AntttIncomingMessage
        16   -> __aeabi_memcpy
       8   AntttInitialize
         8   -> Anttt_reset_rx_buffer
         8   -> LedOff
         8   -> LedOn
         8   -> nrf_gpio_pin_clear
       4   AntttIsGameOver
      16   AntttSM_Active
        16   -> AntttInitialize
        16   -> AntttIsGameOver
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
      16   AntttSM_Gameover
        16   -> AntttInitialize
        16   -> ButtonAcknowledge
        16   -> LedToggle
        16   -> WasButtonPressed
        16   -> nrf_gpio_pin_toggle
        16 __aeabi_uidivmod
       8   AntttSM_Idle
         8   -> ButtonInitialize
         8   -> LedOn
      16   AntttSM_Wait
        16   -> AntttInitialize
        16   -> AntttIsGameOver
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
      24   Anttt_reset_rx_buffer
        24   -> SystemEnterCriticalSection
        24   -> SystemExitCriticalSection
        24   -> __aeabi_memset
       0   nrf_gpio_pin_clear
       4   nrf_gpio_pin_toggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ?_0
       4  ANTTT_SM
      28  AntttHandleIncomingMessage
      28  AntttIncomingMessage
      76  AntttInitialize
     162  AntttIsGameOver
     248  AntttSM_Active
     328  AntttSM_Gameover
      28  AntttSM_Idle
     228  AntttSM_Wait
       1  Anttt_bPendingResponse
      36  Anttt_reset_rx_buffer
       2  Anttt_u16AwayState
       2  Anttt_u16HomeState
       4  Anttt_u8RxData
       4  G_u32AntttFlags
      16  au16WinningCombos
      10  nrf_gpio_pin_clear
      34  nrf_gpio_pin_toggle

 
    17 bytes in section .bss
    16 bytes in section .data
     4 bytes in section .rodata
 1 290 bytes in section .text
 
 1 290 bytes of CODE  memory
     4 bytes of CONST memory
    33 bytes of DATA  memory

Errors: none
Warnings: none
